% Created 2019-03-11 Mon 11:49
% Intended LaTeX compiler: pdflatex
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Daiwei Chen}
\date{\textit{<2019-03-06 Wed>}}
\title{Graph Theory \emph{lite}\\\medskip
\large What am I looking at?}
\hypersetup{
 pdfauthor={Daiwei Chen},
 pdftitle={Graph Theory \emph{lite}},
 pdfkeywords={algorithms graph theory},
 pdfsubject={But it's slow yo},
 pdfcreator={Emacs 26.1 (Org mode 9.1.14)},
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents



\section{Graph Theory \emph{lite}}
\label{sec:org5344fa7}
When you would like to model problems with "complex" relationships.
\begin{description}
\item[{Flights}] Catching flights and changing planes.
\item[{Internet Routing}] The internet is a giant graph. Figuring out the number of hops and which hops to take in order to get to your final destination.
\item[{Circuit Boards}] Making sure connections are efficient.
\end{description}

Basically, things that are connected to each other. A Graph Consists of a set of \textbf{vertices} and \textbf{nodes} that are \emph{connected} by \uline{edges}.\\
Tools: Python - Networkx, c/c++ - nauty.
Assumptions:\\
\begin{itemize}
\item No Self Loops
\item Edges are Unique
\end{itemize}

\subsection{Paths}
\label{sec:org4ccbd01}
\begin{description}
\item[{Path}] List of vertices \(l\) such that \((l[i], l[i+1]) \epsilon E\).\\
On each small step of a path, the 2 nodes much have an edge between them.
\item[{Simple Path}] Path without repeated vertices.
\item[{Cycle}] A (mostly) simple path but the \(1^{st}\) and last vertices are the same. Only the beginning and end are repeated.
\item[{Path Length}] The number of edges in a path.
\end{description}

\subsection{Graphs}
\label{sec:org4c51951}
\begin{description}
\item[{Acyclic Graph}] A graph without \textbf{ANY} cycles.
\item[{Connected Graph}] A graph in which for some a there is an a path from every vertex to every vertex.
\item[{Tree}] Connected acyclic graph.
\begin{itemize}
\item \(|v| -1\) edges.
\end{itemize}
\end{description}

\subsection{Subgraphs}
\label{sec:org0387067}
\begin{description}
\item[{Subgraph}] Only contains verticies and edges of the original graph. Edges must have 2 end-points.
\item[{Spanning Tree}] A subgraph of G that contains all nodes in G and is a tree.
\end{description}
\section{Keeping Track of Graphs}
\label{sec:org744d8fc}
These 2 are not the only two styles of graph representations. There are many, many more and more specialized representations for the correct use case.
\subsection{Adjacency List}
\label{sec:org05c4363}
Just a list, for example:
\begin{center}
\begin{tabular}{lll}
A & -> & B, C, D\\
B & -> & A, C, E\\
C & -> & A, B\\
D & -> & A, E\\
E & -> & B, D\\
\end{tabular}
\end{center}

\subsection{Adjacency Matrix}
\label{sec:org3ee8cdc}
Shows if one node is connected to another.
\begin{center}
\begin{tabular}{lrrrrr}
 & A & B & C & D & E\\
A & 0 & 1 & 1 & 1 & 0\\
B & 1 & 0 & 1 & 0 & 1\\
C & 1 & 1 & 0 & 0 & 0\\
D & 1 & 0 & 0 & 0 & 1\\
E & 0 & 1 & 0 & 1 & 0\\
\end{tabular}
\end{center}

\section{Weighted Graphs}
\label{sec:orgbe1447a}
Just a graph, but the edges has been assigned a value. For example, on a switch, different physical connections could have a weight of how much bandwidth each one gets?

\section{Minimal Spanning Tree}
\label{sec:org97e0274}
You want to find the spanning tree where the total weight is the smallest.

\section{Prim's Algorithm}
\label{sec:orge9b9308}
A minimal spanning tree algorithm.
\begin{verbatim}
def prims(V:set, E:set):
    tree_vertex_set = {V[random(len(V))]} # The vertex starts with ANY vert we want to start with.
    tree_edge_set = {}

    for i=1..len(V)-1:
        # This very much depends on the way you're storing your edges
        find the minimal edge $e_m$ = ($u_m$, $V_m$) such that $u_m \epsilon$ tree_vertex_set and $V_m !\epsilon$ tree_vertex_set
        tree_edge_set.add($e_m)
        tree_vertex_set.add($V_m)

    return tree_edge_set
\end{verbatim}

The way that this algorithm works, is that on each run of every vertex, you always find the minimum edge from the starting point, and move on to the next one. Then you do the same until you run out of verticies.

Let's look at the complexity for prim's algorithm. It's fairly hard to say what the possible complexity for prim's algorithm is looking like because the finding the minimal edge depending on your algorithm for that and how the data is represented.\\
Some examples:\\
\begin{description}
\item[{Prim's (Adjacency Matrix)}] \(O(n^2)\)
\item[{Prim's (List + Binary Heap)}] \(O(e \log n)\)
\item[{Prim's (List + Fibonacci Heap)}] \(O(e + n \log n)\)
\end{description}

\section{Kruskal's Algorithm}
\label{sec:org0388bb6}
It is going to put each vertex into its own set. Then, sort the edges on increasing weight. You start from the lowest weight, and if two vertecies are in different sets, then you combine the sets, and accept that edge. Keep combining as long as your edges are not in the same set.
\end{document}
